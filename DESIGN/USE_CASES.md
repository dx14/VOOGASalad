CS308 Use Cases: VOOGASalad
===================

Use cases involving design of GUIs: 

1. Application will have separate GUIs for the game editor (to create the game) and the game player (to play the game)
2. User can open multiple games without crashing 
3. User can define whether the game will be displayed 2D or 3D (isometric)
4. Allow users to customize the map size of the game, or scaling the unit size in the map (equivalent)

Use cases involving game design: 

17. User can define what the level background image is by uploading a picture file
18. User can create path components (bridges, tunnels, etc.) that have special attributes (underlap other path components, overlap, etc.) and their attributes (image representation, money, size, etc.)
18. User can choose for the player to see the heads-up display
19. User can place scenery/aesthetic items on the map
20. User can define a main base for wave attack gameplay and attributes
18. Authoring environment should have tabs to define aspects of the games (create enemies, create turrets, load image, etc.)
19. Allow users to implement terrain on the map (changes range of towers, speed of units on board)
19. User defines the appearance of the path (with authoring environment creating a default)
19. User can define how many levels the game possesses 
20. User can define the game type (levels, survival, etc.) 
21. User can define the goal of the round (whether to kill all enemies within a time limit, or keep base alive within a time limit, or keep base alive for a certain number of enemies).
22. User defines win/lose conditions, if any (infinite levels (survival mode), defeat enemy base, campaign mode, etc.)
23. User defines what happens upon a win/lose condition being satisfied
21. User can define which enemies show up in which level 
22. User can define the spawn rate for a particular set of enemies 
23. User can define a particular order where enemies are spawned
22. User can define new troops on the board along with their attributes (health, speed, image, money given per kill, range)
23. User can define how player gains money/points (killing enemies, taking territory, bank element/constant gain for each unit time, etc.)
23. User can define whether units are specific to one faction or another (ally, player, enemy)
24. User can define new types of towers along with their attributes (health, cost, damage per attack, attack rate, image representation, upgrades/upgrade costs)
3. User can define a path that enemies take in the authoring environment
4. User can define multiple paths that enemies take in the authoring environment
4. Authoring environment can generate a random path if the user desires
6. User can define locations where the player is allowed to place towers 
7. Authoring environment restricts user in placement of where to place towers depending on the game type selected
8. User can define a boss-level enemy with special attributes (cutscene, special henchman generation, etc.)
9. User can define whether game saves high scores 
9. User can save a game to XML for future development 
10. User can save a game to XML for immediate gameplay 
18. User can define which units are available for user control 
19. User can test the game in the authoring environment indefinite number of times 
20. Authoring environment handles any errors during user testing and returns errors to user in an intuitive way
21. User can link levels together (campaign gameplay)
22. User can define win/lose scenes (default generated by the authoring environment)
23. User can define how levels are differentiated (by difficulty, environment)
24. User can link levels together to create a game
25. User can define cheat codes (automatically go to win/lose conditions, clear enemies on board, infinite money, etc.)
26. Users can define tower attack attributes (area damage, bullet, bullet with area damage, etc.)
27. User can define obstacles to be placed explicitly on the path 
28. Animate Units on the board to interact with the obstacle/aesthetic element/path element (bridge, tunnel) and override default command
29. Authoring environment can implement default sound files for units 
30. Users can override default sounds for units according to unit, action, condition, etc. 
31. Users can create and place powerups
32. Authoring environment can set game to automatically generate powerups 

Use cases involving gameplay: 

8. Player can drag and drop items onto the board during gameplay
20. Player can choose when to advance to the next round/level
1. Player can upgrade turrets and troops during game (after each wave the engine generates a popup screen to display options available)
2.  Player can buy his own troops to send out; they travel backward on the path and collide with enemy troops
2. Player can take control of user-controllable units on the map
15. Player can use cheat codes for different benefits (win, lose, gain money, less enemies, etc.)
20. Visually show the tower range on the map when the user is placing a tower on the map

Use cases involving game resources for the player: 

8. Authoring environment should have a HTML formatted help page for user that describes the components of the authoring environment. 
9. User can load a previously saved game and play it
10. User can see which games are available, including at least each game's name, image, and description
11. User can write a ‘Rules’ dialog that the player can open up during gameplay that describes how to play the game

Use cases involving miscellaneous: 






